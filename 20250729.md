---
typora-root-url: ./assets
---

## 问题1：按照GitHub解决方案修改代码但未解决问题

**日期**：2025-07-29  
**标签**：#\#ROS 调试 #内存泄漏 #Gaussian-LIC #Coco-LIC  
**项目上下文**：XXX项目，按照GitHub解决方案修改代码但未解决问题


### 问题描述
根据Coco-LIC仓库 [issue #6](https://github.com/APRIL-ZJU/Coco-LIC/issues/6) 的解决方案，对代码进行了修改，但是依旧遇见了如下的报错：

![316f0e47f4f46335de6456b204ae4af8](/316f0e47f4f46335de6456b204ae4af8.png)

### 原因分析

根据issue中的方案描述，方案猜测`double free or corruption (out)`可能的原因是：

- **重复释放内存**（如手动删除Ceres框架管理的`CostFunction`）；
- **线程安全问题**（析构时线程未正确终止，导致访问已销毁的对象）

方案的修改设计两个文件：`marginalization_factor.cpp`（边缘化因子析构函数）和`pointcloud_rgbd.cpp`（全局地图类`Global_map`），**均直接针对原错误的潜在原因**。

1. `marginalization_factor.cpp`：解决“重复释放Ceres管理的内存”

   ```cpp
   ~MarginalizationInfo() {
     // 注释掉删除parameter_block_data的部分（避免删除Ceres管理的参数块）
     // for (auto it = parameter_block_data.begin(); it != parameter_block_data.end(); ++it) {
     // 	delete it->second; // 错误：parameter_block_data的指针可能由Ceres管理
     // }
     
     for (int i = 0; i < (int)factors.size(); i++) {
       // 注释掉删除cost_function的部分（由Ceres负责）
       // delete factors[i]->cost_function;
       delete factors[i]; // 保留：Factors是MarginalizationInfo自己管理的
     }
   }
   ```

   **关键错误**： Ceres框架的`ceres::Problem`类**会自动管理`CostFunction`的生命周期**（当`Problem`析构时，会删除所有添加的`CostFunction`）。若手动删除`factors[i]->cost_function`，会导致**double free**（Ceres再删一次），破坏内存结构。 此外，`parameter_block_data`中的指针若指向Ceres优化的参数块（如变量），手动删除也会导致Ceres访问野指针。

2. `pointcloud_rgbd.cpp`：解决“线程安全与析构竞态”

   - **原Global_map类的问题**：

     - 线程`m_thread_service`在析构时未正确终止，可能继续运行并访问已销毁的成员变量（如`m_mutex_img_pose_for_projection`、`m_img_for_projection`）；
     - 无原子变量控制线程退出，导致析构时线程仍在运行，引发**野指针访问**或**内存 corruption**。

   - **修改后的解决措施**：

     - **新增原子变量**：`std::atomic<bool> m_should_terminate_thread;`（用于安全通知线程退出）；

     - **析构函数优化**：

       ```cpp
         ~Global_map() {
           if (m_thread_service && m_thread_service->joinable()) {
             m_should_terminate_thread.store(true); // 原子设置终止标志
             m_thread_service->join(); // 等待线程完成，避免竞态
           }
         }
       ```

     - **线程循环优化**：

       ```cpp
         void service_refresh_pts_for_projection() {
           while (!m_should_terminate_thread.load()) { // 循环检查终止标志
             std::this_thread::sleep_for(...);
             if (m_should_terminate_thread.load()) break; // 及时退出
             // 后续操作...
           }
         }
       ```

但是，修改后依旧出现了问题：

1. **终端错误**：

   ```bash
   double free or corruption (out)
   ```

   - 核心含义：**内存 corruption（破坏）**，通常由**内存越界写**（如数组访问超过边界）或**重复释放内存**（double free）导致。
   - "out" 表示**写操作越界**（写入了超过 malloc 分配的内存块范围），破坏了 malloc 的内存管理结构。

2. **异常类型**：

   ```cpp
   Aborted
   ```

   - 原因：程序收到 `SIGABRT` 信号（通常由 glibc 的内存检测机制触发，如 malloc 发现管理结构损坏）。


### 解决方案
根据目前已知的内容，现在有两种可能：

1. 若这些修改时有效的，那么已解决的内容为 **重复释放内存** 和 **线程安全问题** ，剩下的问题为 **内存越界写** ，需要进行问题的排除。
2. 若不能确定这些修改是否有效，那么还要在修改后进行验证：
   - 使用**AddressSanitizer（asan）**编译验证（确认无内存错误）；
   - 测试线程终止逻辑（如退出程序时，线程是否正确join）。

#### 1. ROS项目中使用ASan

1. **确定目标包**
   找到需要验证的ROS包（如包含`trajectory_estimator.cpp`、`marginalization_factor.cpp`的包，包名为`coco_lic`）。

2. **修改包的CMakeLists.txt**
   针对包中的**可执行文件（`add_executable`）\**或\**动态库（`add_library`）**，添加ASan编译/链接选项。
   包中会生成一个名为`odometry_node`的可执行文件，原`CMakeLists.txt`内容如下：

   ```cmake
   cmake_minimum_required(VERSION 3.0.2)
   project(cocolic)
   
   find_package(...)
   
   include_directories(...)
   
   add_library(...)
   
   add_executable(odometry_node ...)
   
   target_link_libraries(...)
   ```

   **添加ASan选项后的修改**
   需为目标（`odometry_node`）添加**编译选项**和**链接选项**：

   ```cmake
   # 1. 为可执行文件添加ASan编译选项
   target_compile_options(odometry_node PRIVATE
     -fsanitize=address        # 开启ASan（内存错误检测）
     -fno-omit-frame-pointer   # 保留栈帧指针，生成更清晰的回溯
     -g                        # 生成调试信息（需配合-g才能定位行号）
   )
   
   # 2. 为可执行文件添加ASan链接选项
   target_link_options(odometry_node PRIVATE
     -fsanitize=address        # 链接时开启ASan
   )
   
   # 3. 保留原链接库（无需修改）
   target_link_libraries(odometry_node ...)
   ```

   **关键选项说明**：

   - `-fsanitize=address`：开启ASan的核心选项（检测内存越界、重复释放等）；
   - `-fno-omit-frame-pointer`：避免编译器优化栈帧，确保ASan能生成**准确的函数调用栈**（方便定位错误位置）；
   - `-g`：生成调试信息（必须添加，否则ASan无法显示错误对应的**源文件行号**）。

3. **清理并重新编译**

   ASan需要**重新编译**才能生效，需先清理之前的编译结果：

   ```bash
   # 进入catkin工作空间（如~/catkin_ws）
   cd ~/catkin_coco
   
   # 清理所有编译产物（可选，确保ASan选项被正确应用）
   catkin_make clean
   
   # 编译目标包
   catkin_make -DCMAKE_BUILD_TYPE=Debug
   ```

4. **运行节点：**

   ```bash
   roslaunch /catkin_coco/src/Coco-LIC/launch/odometry.launch
   ```

#### 2. 运行结果与分析

1. **节点运行结果：**

   ```bash
   =================================================================
   ==70284==ERROR: AddressSanitizer: attempting free on address which was not malloc()-ed: 0x606000337840 in thread T0
       #0 0x7365520cf40f in __interceptor_free ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:122
       #1 0x5b00ef7c198c in void Eigen::internal::permute_symm_to_fullsymm<2, Eigen::SparseMatrix<double, 0, int>, 0>(Eigen::SparseMatrix<double, 0, int> const&, Eigen::SparseMatrix<Eigen::SparseMatrix<double, 0, int>::Scalar, 0, Eigen::SparseMatrix<double, 0, int>::StorageIndex>&, Eigen::SparseMatrix<double, 0, int>::StorageIndex const*) [clone .constprop.0] (/catkin_coco/devel/lib/cocolic/odometry_node+0x88a98c)
       #2 0x5b00ef7cd452 in Eigen::SimplicialCholeskyBase<Eigen::SimplicialLDLT<Eigen::SparseMatrix<double, 0, int>, 2, Eigen::NaturalOrdering<int> > >::ordering(Eigen::SparseMatrix<double, 0, int> const&, Eigen::SparseMatrix<double, 0, int> const*&, Eigen::SparseMatrix<double, 0, int>&) (/catkin_coco/devel/lib/cocolic/odometry_node+0x896452)
       #3 0x5b00ef7cd7c2 in ceres::internal::EigenSparseCholeskyTemplate<Eigen::SimplicialLDLT<Eigen::SparseMatrix<double, 0, int>, 2, Eigen::NaturalOrdering<int> > >::Factorize(ceres::internal::CompressedRowSparseMatrix*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*) (/catkin_coco/devel/lib/cocolic/odometry_node+0x8967c2)
       #4 0x5b00ef69e624 in ceres::internal::SparseCholesky::FactorAndSolve(ceres::internal::CompressedRowSparseMatrix*, double const*, double*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*) (/catkin_coco/devel/lib/cocolic/odometry_node+0x767624)
       #5 0x5b00ef69f34f in ceres::internal::SparseNormalCholeskySolver::SolveImpl(ceres::internal::BlockSparseMatrix*, double const*, ceres::internal::LinearSolver::PerSolveOptions const&, double*) (/catkin_coco/devel/lib/cocolic/odometry_node+0x76834f)
       #6 0x5b00ef673866 in ceres::internal::TypedLinearSolver<ceres::internal::BlockSparseMatrix>::Solve(ceres::internal::LinearOperator*, double const*, ceres::internal::LinearSolver::PerSolveOptions const&, double*) (/catkin_coco/devel/lib/cocolic/odometry_node+0x73c866)
       #7 0x5b00ef66020f in ceres::internal::LevenbergMarquardtStrategy::ComputeStep(ceres::internal::TrustRegionStrategy::PerSolveOptions const&, ceres::internal::SparseMatrix*, double const*, double*) (/catkin_coco/devel/lib/cocolic/odometry_node+0x72920f)
       #8 0x5b00ef63a97d in ceres::internal::TrustRegionMinimizer::ComputeTrustRegionStep() (/catkin_coco/devel/lib/cocolic/odometry_node+0x70397d)
       #9 0x5b00ef63ee09 in ceres::internal::TrustRegionMinimizer::Minimize(ceres::internal::Minimizer::Options const&, double*, ceres::Solver::Summary*) (/catkin_coco/devel/lib/cocolic/odometry_node+0x707e09)
       #10 0x5b00ef61291d in ceres::Solver::Solve(ceres::Solver::Options const&, ceres::Problem*, ceres::Solver::Summary*) (/catkin_coco/devel/lib/cocolic/odometry_node+0x6db91d)
       #11 0x5b00ef61310d in ceres::Solve(ceres::Solver::Options const&, ceres::Problem*, ceres::Solver::Summary*) (/catkin_coco/devel/lib/cocolic/odometry_node+0x6dc10d)
       #12 0x5b00ef2e34df in cocolic::TrajectoryEstimator::Solve(int, bool, int) /catkin_coco/src/Coco-LIC/src/odom/trajectory_estimator.cpp:506
       #13 0x5b00ef19a27e in cocolic::TrajectoryManager::InitTrajWithPropagation() /catkin_coco/src/Coco-LIC/src/odom/trajectory_manager.cpp:309
       #14 0x5b00ef19b697 in cocolic::TrajectoryManager::PredictTrajectory(long, long, long, int, bool) /catkin_coco/src/Coco-LIC/src/odom/trajectory_manager.cpp:271
       #15 0x5b00ef489608 in cocolic::OdometryManager::ProcessLICData() /catkin_coco/src/Coco-LIC/src/odom/odometry_manager.cpp:291
       #16 0x5b00ef493024 in cocolic::OdometryManager::SolveLICO() /catkin_coco/src/Coco-LIC/src/odom/odometry_manager.cpp:256
       #17 0x5b00ef493024 in cocolic::OdometryManager::RunBag() /catkin_coco/src/Coco-LIC/src/odom/odometry_manager.cpp:223
       #18 0x5b00ef04c645 in main /catkin_coco/src/Coco-LIC/src/odometry_node.cpp:44
       #19 0x7365462b0082 in __libc_start_main ../csu/libc-start.c:308
       #20 0x5b00ef055b9d in _start (/catkin_coco/devel/lib/cocolic/odometry_node+0x11eb9d)
   
   0x606000337840 is located 32 bytes inside of 56-byte region [0x606000337820,0x606000337858)
   allocated by thread T0 here:
       #0 0x7365520cf808 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:144
       #1 0x5b00ef1d03e8 in Eigen::internal::handmade_aligned_malloc(unsigned long) /usr/include/eigen3/Eigen/src/Core/util/Memory.h:88
       #2 0x5b00ef1d03e8 in Eigen::internal::aligned_malloc(unsigned long) /usr/include/eigen3/Eigen/src/Core/util/Memory.h:164
       #3 0x5b00ef7c1a1c in void Eigen::internal::permute_symm_to_fullsymm<2, Eigen::SparseMatrix<double, 0, int>, 0>(Eigen::SparseMatrix<double, 0, int> const&, Eigen::SparseMatrix<Eigen::SparseMatrix<double, 0, int>::Scalar, 0, Eigen::SparseMatrix<double, 0, int>::StorageIndex>&, Eigen::SparseMatrix<double, 0, int>::StorageIndex const*) [clone .constprop.0] (/catkin_coco/devel/lib/cocolic/odometry_node+0x88aa1c)
   
   SUMMARY: AddressSanitizer: bad-free ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:122 in __interceptor_free
   ==70284==ABORTING
   ```

2. **结果分析：**
   将报错信息上传豆包和deepseek，分析总结如下：

   1. **错误类型**：`bad-free`（非法释放），试图释放的地址**0x606000337840**未被`malloc()`分配过。
   2. **地址关联**：该地址位于一个**56字节的内存区域**（`[0x606000337820, 0x606000337858)`），而该区域是由Eigen的`aligned_malloc()`分配的（用于稀疏矩阵操作）。
   3. **错误位置**：错误发生在Eigen库的`permute_symm_to_fullsymm`函数（稀疏矩阵对称转置操作），栈帧上层是Ceres Solver的线性求解过程（`EigenSparseCholeskyTemplate::Factorize`）。

   结合Eigen库的内存管理逻辑和栈帧信息，**最可能的原因**是：

   1. **指针偏移错误**：在`permute_symm_to_fullsymm`函数中，**释放的指针不是`aligned_malloc()`返回的原始地址**（而是其偏移量，如`ptr + 32`），导致ASan检测到非法释放。
   2. **内存越界写**：用户代码或Eigen库中存在**越界写操作**，修改了`malloc()`返回的指针值（如栈上的指针变量被越界覆盖），导致释放时指针指向错误地址。
   3. **Eigen库已知bug**：特定版本的Eigen（如3.3.7及以下）在稀疏矩阵排列操作中存在**内存释放逻辑错误**（如释放偏移后的指针）。

#### 3. 后续解决方案

这个问题需要在 Eigen 库的代码中修复，正确的做法是使用与`aligned_malloc`对应的`aligned_free`函数来释放内存。由于这是 Eigen 库内部的问题，你可以尝试以下解决方法：

1. **更新 Eigen 库**：确认你使用的是最新版本的 Eigen 库，有时这类问题已经在新版本中得到修复
2. **检查自定义代码**：如果你在自己的代码中调用了 Eigen 的内存分配函数，确保使用正确的释放函数
3. **临时补丁**：如果无法更新 Eigen 库，可以尝试在调用 Eigen 函数前后添加适当的内存管理代码
4. **联系库维护者**：如果确认是 Eigen 库的问题，可以向 Eigen 开发团队报告这个问题

### 经验总结

本次问题排查与解决过程，暴露了在复杂项目（涉及ROS、Ceres、Eigen等多框架）中内存管理与调试的典型挑战，总结关键经验如下：


1. **框架内存管理的“边界意识”是核心**  
   第三方框架（如Ceres、Eigen）通常有独立的内存管理逻辑，手动干预需格外谨慎：  
   - Ceres会自动管理`CostFunction`和参数块的生命周期，手动`delete`易导致重复释放（double free）；  
   - Eigen的`aligned_malloc`需对应`aligned_free`释放，混用标准`free`会引发“非法释放（bad-free）”，尤其在稀疏矩阵操作中需警惕库内部内存逻辑。  
   **原则**：优先信任框架的自动管理，仅在明确框架不负责时（如自定义动态分配对象）手动释放。


2. **AddressSanitizer（ASan）是内存错误的“手术刀”**  
   面对“double free”“内存越界”等隐晦问题，ASan能精准定位错误类型（如bad-free）、涉事内存地址、分配/释放栈帧，大幅缩短排查周期。  
   **实践**：ROS项目中需在`CMakeLists.txt`中为目标节点添加`-fsanitize=address`等编译选项，并配合`-g`生成调试信息，确保能定位到具体源码行号。


3. **线程安全需“闭环设计”**  
   线程的创建与销毁必须形成完整逻辑：  
   - 用原子变量（如`std::atomic<bool>`）作为退出标志，避免依赖非原子变量导致的竞态条件；  
   - 析构函数中必须通过`join()`等待线程终止，防止线程访问已销毁的成员变量（野指针）。  
   **教训**：遗漏线程`join()`或退出标志检查，会导致看似“已修复”的线程问题反复出现。


4. **第三方库版本与兼容性不可忽视**  
   本次问题中Eigen库的稀疏矩阵操作可能存在版本相关bug（如特定版本中`permute_symm_to_fullsymm`的释放逻辑错误）。  
   **应对**：遇到库内部错误时，优先尝试升级至最新稳定版；若无法升级，可查阅官方issue或提交bug报告，必要时通过临时补丁规避（如替换问题函数实现）。


5. **问题排查需“分层验证”**  
   解决问题时应分步骤验证假设，而非一次性堆砌修改：  
   - 先验证“重复释放”和“线程安全”修改是否生效（如通过ASan确认无相关错误）；  
   - 若问题仍存在，再聚焦剩余可能（如内存越界、库内部逻辑），避免多修改点混淆因果。
